#!/usr/bin/env node

// Libraries
var co = require('co');
var jsonfile = require('jsonfile');
var tmp = require('tmp-promise');
var path = require('path');
var stream = require('stream');
var Promise = require('bluebird');
var fs = require('fs');
Promise.promisifyAll(fs);
var Docker = require("dockerode-bluebird");
var docker = new Docker({socketPath: '/var/run/docker.sock'});

// Whiplash
var wdb = require('project-whiplash');
var options = {
    host: process.env.WHIPLASH_API_HOST,
    port: process.env.WHIPLASH_API_PORT,
    admin_client: "admin-scheduler",
    admin_access_token: process.env.WHIPLASH_ADMIN_SCHEDULER_TOKEN,
    admin_password: process.env.WHIPLASH_ADMIN_PASSWORD
};
wdb.connect(options, function() {
var Models = wdb.get().models;
var Executables = wdb.get().executables;
var Properties = wdb.get().properties;

// Global variables
var working = false;
var pulled_containers = [];
var ascii_regex = /[^A-Za-z 0-9 \.,\?""!@#\$%\^&\*\(\)-_=\+;:<>\/\\\|\}\{\[\]`~]*/g;

// Main loop
setInterval(function () {
    if (!working) {
        find_unresolved_properties();
    }
}, 1000);

// Query whiplash for unresolved properties
function find_unresolved_properties() {
    console.log('querying for unresolved properties...');
    if (!working) {
        working = true;
        co(function *() {
            var property = yield Properties.update_one({status: "unresolved"}, {status: "running"});
            if (property) {
                console.log('found unresolved property', property._id);
                resolve_property(property);
            } else {
                throw 'found nothing!';
            }
        }).catch(function(err) {
            working = false;
            console.log(err);
        });
    }
}

// Resolve unresolved property
function resolve_property(property) {
    var executable_id = property.executable_id;
    var model_id = property.input_model_id;
    co(function *() {
        var executable = yield Executables.query_one({_id: executable_id}, []);
        var model = yield Models.query_one({_id: model_id}, []);
        if (executable && model) {
            yield pull_container(executable.path);
            run_container(executable, model, property);
        }
        else throw 'Missing model '+model_id+' or executable '+executable_id+' for property '+property._id;
    }).catch(function(err) {
        set_errored(property, err);
    });
}

// Pull the container
function pull_container(container) {
    return new Promise(function(resolve, reject) {
        if (pulled_containers.indexOf(container) < 0) {
            co(function *() {
                console.log("pulling", container);
                var stream = yield docker.pullAsync(container);
                docker.modem.followProgress(stream, onFinished, onProgress);
                function onFinished(err, output) {
                    if (err) reject(err);
                    else {
                        pulled_containers.push(container);
                        resolve();
                    }
                }
                function onProgress(event) {}
            }).catch(function(err) {
                reject(err);
            });
        } else {
            console.log("container already pulled", container);
            resolve();
        }
    });
}

// Run the container
function run_container(executable, model, property) {
    console.log("running", executable.path);
    co(function *() {
        // Make temporary files
        var launch_work_dir = process.env.WHIPLASH_LAUNCH_WORK_DIR;
        var in_file = yield tmp.tmpName({template: launch_work_dir+'/tmp-in-XXXXXX'});
        var out_file = yield tmp.tmpName({template: launch_work_dir+'/tmp-out-XXXXXX'});

        // Write input
        if (model.format === "cnf") { // SAT format
            console.log("writing CNF...");
            in_file += ".cnf";
            yield fs.writeFileAsync(in_file, model.content);
        } else { // JSON format
            console.log("writing JSON...");
            model.params = property.params;
            jsonfile.writeFileSync(in_file, model);
        }

        // Create container
        var run_work_dir = '/input';
        var container = yield docker.createContainerAsync({
            Image: executable.path,
            Cmd: [run_work_dir+'/'+path.basename(in_file)],
            Volumes: {run_work_dir: {}}
        });

        // Create stream from container to out_file
        var stream = yield container.attachAsync({
            stream: true,
            stdout: true,
            stderr: true
        });
        stream.pipe(fs.createWriteStream(out_file));

        // Start container
        console.log("starting container...");
        var host_work_dir = process.env.WHIPLASH_HOST_WORK_DIR;
        yield container.startAsync({
            'Binds': [host_work_dir+':'+run_work_dir]
        });
        var hrstart = process.hrtime();

        // Set timeout
        var timeout = 0;
        if (!model.timeout) {
            if (!property.timeout) timeout = 600; // Default is 1 hr.
            else timeout = property.timeout;
        } else timeout = model.timeout;
        container.stopAsync({t: timeout});

        // Wait for container to finish
        var data = yield container.waitAsync();
        console.log("container finished...");
        var hrdiff = process.hrtime(hrstart);
        var walltime = (hrdiff[0]*1e9 + hrdiff[1])/1.e9; // time in seconds

        // Read output, check for errors, remove file
        var log = yield fs.readFileAsync(out_file, 'ascii');
        log = log.replace(ascii_regex, '');
        fs.unlink(out_file);

        // Remove container
        container.removeAsync();

        // Read result, remove file
        var result_file = "";
        if (model.format === "cnf") { // SAT format
            var n = log.lastIndexOf("\nv ");
            if (n < 0) {
                var n = log.lastIndexOf("v ");
                if (n < 0) throw "No output found";
            }
            var chopped_log = log.substr(n+2, log.length);
            var variables = chopped_log;
            if (chopped_log.indexOf("\n") >= 0)
                variables = chopped_log.substr(0, chopped_log.indexOf("\n"));
            result_file = yield tmp.tmpName({template: launch_work_dir+'/tmp-result-XXXXXX'});
            yield fs.writeFileAsync(result_file, variables);
        } else { // JSON format
            if (data.StatusCode === 137) {
                throw "Timed out after "+timeout+" seconds";
            } else if (data.StatusCode !== 0) {
                console.log(data);
                throw log
            }
            result_file = in_file;
        }
        var result = yield verify_result(model.format, in_file, result_file);
        fs.unlink(in_file);

        // Set necessary fields
        result.property_id = property._id;
        result.owner = property.owner;

        // Push result back to database
        var obj = yield Models.commit_one(result);
        var update = {
                status: "resolved",
                output_model_id: obj.ids[0],
                log: log,
                walltime: walltime
        };
        if (model.format === "cnf")
            update.cost = result.cost;
        yield Properties.update_one({_id: property._id}, update);
        console.log('resolved property', property._id);

        // Start looking again
        working = false;
    }).catch(function(err) {
        set_errored(property, err);
    });
}

// Verify result
function verify_result(format, in_file, result_file) {
    return new Promise(function(resolve, reject) {
        co(function *() {
            if (format === "cnf") { // SAT format
                var cost_evaluator = "iliazin/cost_evaluator_sat:v1";
                yield pull_container(cost_evaluator);

                var launch_work_dir = process.env.WHIPLASH_LAUNCH_WORK_DIR;
                var run_work_dir = '/input';
                var container = yield docker.createContainerAsync({
                    Image: 'iliazin/cost_evaluator_sat:v1',
                    Cmd: [run_work_dir+'/'+path.basename(in_file), run_work_dir+'/'+path.basename(result_file)],
                    Volumes: {run_work_dir: {}}
                });

                // Create stream from container to out_file
                var out_file = yield tmp.tmpName({template: launch_work_dir+'/tmp-out-XXXXXX'});
                var stream = yield container.attachAsync({
                    stream: true,
                    stdout: true,
                    stderr: true
                });
                stream.pipe(fs.createWriteStream(out_file));

                // Start container
                console.log("starting evaluator...");
                var host_work_dir = process.env.WHIPLASH_HOST_WORK_DIR;
                yield container.startAsync({
                    'Binds': [host_work_dir+':'+run_work_dir]
                });

                // Wait for container to finish
                var data = yield container.waitAsync();
                console.log("container finished...");

                // Read output, check for errors, remove file
                var log = yield fs.readFileAsync(out_file, 'ascii');
                fs.unlink(out_file);
                if (data.StatusCode !== 0) throw log

                // Remove container
                container.removeAsync();

                var num = log.replace(ascii_regex, '');
                var configuration = yield fs.readFileAsync(result_file, 'ascii');
                configuration = configuration.replace(ascii_regex, '');
                var result = {
                    cost: Number(num),
                    content: configuration
                };
                resolve(result);
            } else { // JSON format
                resolve(jsonfile.readFileSync(result_file));
            }
        }).catch(function(err) {
            console.log(err);
            reject(err);
        });
    });
}

// Catch all error function
function set_errored(property, err) {
    working = false;
    console.log(err);
    Properties.update_one({_id: property._id}, {
            status: "errored",
            err: err
        }
    );
}

});
