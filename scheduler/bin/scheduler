#!/usr/bin/env node

// Libraries
var co = require('co');
var jsonfile = require('jsonfile');
var tmp = require('tmp-promise');
var path = require('path');
var stream = require('stream');
var Promise = require('bluebird');
var fs = require('fs');
Promise.promisifyAll(fs);
var Docker = require("dockerode-bluebird");
var docker = new Docker({socketPath: '/var/run/docker.sock'});

// Whiplash
var wdb = require('project-whiplash');
var options = {
    host: process.env.WHIPLASH_API_HOST,
    port: process.env.WHIPLASH_API_PORT,
    admin_client: "admin-scheduler",
    admin_access_token: process.env.WHIPLASH_ADMIN_SCHEDULER_TOKEN,
    admin_password: process.env.WHIPLASH_ADMIN_PASSWORD
};
wdb.connect(options, function() {

// Global variables
var working = false;
var pulled_containers = [];

// Main loop
setInterval(function () {
    if (!working) {
        find_unresolved_properties();
    }
}, 1000);

// Query whiplash for unresolved properties
function find_unresolved_properties() {
    console.log('querying for unresolved properties...');
    if (!working) {
        working = true;
        co(function *() {
            var property = yield wdb.get().update_one("properties", wdb.get().admin_access_token, {status: "unresolved"}, {status: "running"});
            if (property) {
                console.log('found unresolved property', property._id);
                resolve_property(property);
            } else {
                throw 'found nothing!';
            }
        }).catch(function(err) {
            working = false;
            console.log(err);
        });
    }
}

// Resolve unresolved property
function resolve_property(property) {
    var executable_id = property.executable_id;
    var model_id = property.input_model_id;
    co(function *() {
        var executable = yield wdb.get().query_one("executables", wdb.get().admin_access_token, {_id: executable_id});
        var model = yield wdb.get().query_one("models", wdb.get().admin_access_token, {_id: model_id});
        if (executable && model) pull_container(executable, model, property);
        else throw 'Missing model '+model_id+' or executable '+executable_id+' for property '+property._id;
    }).catch(function(err) {
        set_errored(property._id, err);
    });
}

// Pull the container
function pull_container(executable, model, property) {
    if (pulled_containers.indexOf(executable.path) < 0) {
        co(function *() {
            console.log("pulling", executable.path);
            var stream = yield docker.pullAsync(executable.path);
            docker.modem.followProgress(stream, onFinished, onProgress);
            function onFinished(err, output) {
                if (err) set_errored(property._id, err);
                else {
                    pulled_containers.push(executable.path);
                    run_container(executable, model, property);
                }
            }
            function onProgress(event) {}
        }).catch(function(err) {
            set_errored(property._id, err);
        });
    } else {
        console.log("container already pulled", executable.path);
        run_container(executable, model, property);
    }
}

// Run the container
function run_container(executable, model, property) {
    console.log("running", executable.path);
    co(function *() {
        // Make temporary files
        var launch_work_dir = process.env.WHIPLASH_LAUNCH_WORK_DIR;
        var in_file = yield tmp.tmpName({template: launch_work_dir+'/tmp-in-XXXXXX'});
        var out_file = yield tmp.tmpName({template: launch_work_dir+'/tmp-out-XXXXXX'});

        // Write input
        if (model.format === "cnf") { // SAT format
            yield fs.writeFileAsync(in_file, model.content);
        } else { // JSON format
            model.params = property.params;
            jsonfile.writeFileSync(in_file, model);
        }

        // Create container
        var run_work_dir = '/input';
        var container = yield docker.createContainerAsync({
            Image: executable.path,
            Cmd: [run_work_dir+'/'+path.basename(in_file)],
            Volumes: {run_work_dir: {}}
        });

        // Create stream from container to out_file
        var stream = yield container.attachAsync({
            stream: true,
            stdout: true,
            stderr: true
        });
        stream.pipe(fs.createWriteStream(out_file));

        // Start container
        var host_work_dir = process.env.WHIPLASH_HOST_WORK_DIR;
        yield container.startAsync({
            'Binds': [host_work_dir+':'+run_work_dir]
        });

        // Wait for container to finish
        // TODO: add timeout
        var hrstart = process.hrtime();
        var data = yield container.waitAsync();
        var hrdiff = process.hrtime(hrstart);
        var walltime = (hrdiff[0]*1e9 + hrdiff[1])/1.e9; // time in seconds

        // Read output, check for errors, remove file
        var log = yield fs.readFileAsync(out_file, 'ascii');
        fs.unlink(out_file);
        if (data.StatusCode !== 0) {
            throw log;
        }

        // Remove container
        container.removeAsync();

        // Read result, remove file
        var result = jsonfile.readFileSync(in_file);
        fs.unlink(in_file);

        // Set necessary fields
        result.property_id = property._id;
        result.owner = property.owner;

        // Push result back to database
        var obj = yield wdb.get().commit_one('models', wdb.get().admin_access_token, result);
        yield wdb.get().update_one('properties', wdb.get().admin_access_token, {_id: property._id}, {
                status: "resolved",
                output_model_id: obj.ids[0],
                log: log,
                walltime: walltime
            }
        );
        console.log('resolved property', property._id);
        working = false;
    }).catch(function(err) {
        set_errored(property._id, err);
    });
}

// Catch all error function
function set_errored(property_id, err) {
    working = false;
    console.log(err);
    wdb.get().update_one('properties', wdb.get().admin_access_token, {_id: property._id}, {
            status: "errored",
            log: log
        }
    );
}

});
