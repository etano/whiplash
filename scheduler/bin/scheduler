#!/usr/bin/env node

var co = require('co');
var jsonfile = require('jsonfile');
var tmp = require('tmp-promise');
var path = require('path');
var stream = require('stream');
var Promise = require('bluebird');
var fs = require('fs');
Promise.promisifyAll(fs);
var Docker = require("dockerode-bluebird");
var docker = new Docker({socketPath: '/var/run/docker.sock'});
var db = require(process.cwd()+'/libs/db')

var XXHash = require('xxhash').XXHash64;

function checksum(str) {
    var hash = new XXHash(0xCAFEBABE); // note: same seed each time
    var buffer = new Buffer(str, 'utf8');
    hash.update(buffer);
    var res = hash.digest('hex');
    return res;
}

function smart_stringify(obj) {
    if(typeof(obj) !== 'object') {
        return JSON.stringify(obj);
    }
    var keys = Object.keys(obj).sort();
    var str = '{';
    for(var i = 0; i < keys.length; i++) {
        str += '"' + keys[i] + '":' + smart_stringify(obj[keys[i]]) + ',';
    }
    str += '}';
    return str;
}

function hash(obj) {
    return checksum(smart_stringify(obj));
}

db.connect(function() {

    var Properties = db.get().collection("properties");
    var Executables = db.get().collection("executables");
    var Models = db.get().collection("models");
    var working = false;
    var pulled_containers = [];

    setInterval(function () {
        if (!working) {
            look_for_something_to_do();
        }
    }, 1000);

    function look_for_something_to_do() {
        console.log('looking for something to do...');
        if (!working) {
            working = true;
            co(function *() {
                var res = yield Properties.findOneAndUpdate({status: "unresolved"}, {$set: {status: "running"}});
                var property = res.value;
                if (property) {
                    console.log('found unresolved property', property._id);
                    do_something(property);
                } else {
                    throw 'found nothing!';
                }
            }).catch(function(err) {
                working = false;
                console.log(err);
            });
        }
    }

    function do_something(property) {
        var executable_id = property.executable_id;
        var model_id = property.input_model_id;
        co(function *() {
            var executable = yield Executables.findOne({_id: executable_id});
            var model = yield Models.findOne({_id: model_id});
            if (executable && model) {
                resolve_property(executable, model, property);
            } else {
                throw 'Missing model '+model_id+' or executable '+executable_id+' for property '+property._id;
            }
        }).catch(function(err) {
            set_errored(property._id, err);
        });
    }

    function resolve_property(executable, model, property) {
        if (pulled_containers.indexOf(executable.path) < 0) {
            co(function *() {
                console.log("pulling", executable.path);
                var stream = yield docker.pullAsync(executable.path);
                docker.modem.followProgress(stream, onFinished, onProgress);
                function onFinished(err, output) {
                    if (!err) {
                        pulled_containers.push(executable.path);
                        run_container(executable, model, property);
                    } else {
                        set_errored(property._id, err);
                    }
                }
                function onProgress(event) {}
            }).catch(function(err) {
                set_errored(property._id, err);
            });
        } else {
            console.log("container already pulled", executable.path);
            run_container(executable, model, property);
        }
    }

    function run_container(executable, model, property) {
        console.log("running", executable.path);
        var tmp_dir = process.env.PWD; //TODO: make sure this is secure
        var in_file = tmp.tmpNameSync({template: tmp_dir+'/tmp-in-XXXXXX'});
        var out_file = tmp.tmpNameSync({template: tmp_dir+'/tmp-out-XXXXXX'});
        co(function *() {
            var file_name = path.basename(in_file);
            var work_dir = path.dirname(in_file);
            model.params = property.params;
            jsonfile.writeFileSync(in_file, model);

            var container = yield docker.createContainerAsync({
                Image: executable.path,
                Cmd: ['/input/'+file_name],
                Volumes: {'/input': {}}
            });

            var stream = yield container.attachAsync({
                stream: true,
                stdout: true,
                stderr: true
            });
            stream.pipe(fs.createWriteStream(out_file));

            yield container.startAsync({
                'Binds': [work_dir+':/input']
            });

            data = yield container.waitAsync();

            var log = yield fs.readFileAsync(out_file, 'ascii');
            if (data.StatusCode !== 0) {
                throw log;
            }

            yield container.removeAsync();

            var result = jsonfile.readFileSync(in_file);
            result.property_id = property._id;

            var id_obj = {};
            for (key in result) {
                if ((key !== 'timestamp') && (key !== '_id')) {
                    id_obj[key] = result[key];
                }
            }
            result._id = hash(id_obj);
            result.owner = property.owner;

            var obj = yield Models.insertOne(result);
            yield Properties.findOneAndUpdate({_id: property._id}, {
                $set: {
                    status: "resolved",
                    output_model_id: obj.insertedId,
                    log: log
                }
            });

            console.log('resolved property', property._id);
            working = false;
        }).catch(function(err) {
            set_errored(property._id, err);
        });
    }

    function set_errored(property_id, err) {
        working = false;
        console.log(err);
        Properties.findOneAndUpdate({_id: property_id}, {
            $set: {
                status: "errored",
                log: err
            }
        }, function (err, obj) {
            console.log(err);
        });
    }

});
